要探讨设计的本质，我们必须先搞清楚设计的目的。只要知道了设计的目的，然后将设计所追求的结果进行量化，我们就能够很好的评判一个设计的好坏。

### 1. 为什么需要软件设计
关于为什么做设计，我问过很多同行，其中包含刚从事软件行业的新人，也有很多十余年编码经验的老手。得到的答案无外乎：代码变得更为优美，扩展性更好，也更易于维护。
我们如果使用5Why分析法，不难追寻出设计的最终目的。

  - **为什么要做设计？**
    因为可以让代码扩展性更好，更易维护。
  - **为什么要让代码的扩展性更好，更易维护？**
    因为这样后续修改或增加需求可以更简单。
  - **让修改和增加需求变得简单又是要干嘛？**
    这样我们需要改动的代码就很少。
  - **改动的代码很少对我们有什么好处？**
    代码改动少就可以节省很多工作量。
  - **为什么要节省工作量？**
    可以省时间。
  - **省时间有什么好处？**
    给公司省钱。

> 摘自维基百科 **Five whys** (or **5 whys**) is an [iterative](https://en.jinzhao.wiki/wiki/Iteration) interrogative [technique](https://en.jinzhao.wiki/wiki/Skill) used to explore the [cause-and-effect](https://en.jinzhao.wiki/wiki/Causality) relationships underlying a particular problem.[[1\]](https://en.jinzhao.wiki/wiki/Five_whys#cite_note-1) The primary goal of the technique is to determine the [root cause](https://en.jinzhao.wiki/wiki/Root_cause) of a [defect](https://en.wiktionary.org/wiki/defect) or problem by repeating the question "Why?". Each answer forms the basis of the next question. The "five" in the name derives from an anecdotal observation on the number of iterations needed to resolve the problem.

任何一件我们不厌其烦推崇的事情，都有其存在的价值，对于企业往往其价值都归结于“钱”上面。

如果我们说软件设计的最终目的是为了给公司**省钱**，大概率不会有人提出反对意见，不过这个结论也未免过于偷懒。而且简单的将设计的本质归纳于“钱”，也无法区分软件设计和其他事物的特别之处，因为在软件的整个生命周期中，我们的很多行为几乎都是为了省钱。诸如：

- 提高人员作战能力（激励，培训）;
- 更好的协同（管理，流程）;
- 节约软件的成本（可测试性，易用性，硬件成本，人力成本）;
- 营销（广告，良好的运营，销售策略）;
- 甚至一个HR通过自身的“忽悠”，用更少的薪酬招聘到一个更优秀的程序员，也可以成为一笔可观的收入;

所以，我们必须搞清楚软件设计是如何省钱的。

### 2. 软件设计如何省钱

我们假定有两个完全相同的团队A和B（产品经理，项目经理，需求分析师，架构师，测试人员，开发人员，销售、运维和一线人员的能力和人数都完全相同）在完全相同的条件下（相同的时间，地点，硬件设施，软件设施等）开发一款相同的软件（相同的客户，相同的功能需求，时间要求，性能要求，部署要求，所有DFX等等），唯独只有他们负责软件设计的的架构师不一样。那么评判这两个架构师的好坏会变得格外简单，最终哪个团队赚的钱多，我们就可以说哪个软件设计师在这个项目中表现得更为出色，或者说叫**设计更好**。

我们知道：利润 = 销售额 - 成本。
而软件设计肯定是不会改变软件的销售额，因为我们已经假定背景，销售，产品等都完全一样了。但有人不会太认可这个结论，他们认为客户关系，销售人员的能力，销售策略之类的因素确实与软件设计正交无关，但是软件产品自身的好坏却与软件设计的好坏强相关，好的架构师设计出来的软件性能可能更好，产品质量更高bug更少，占用的硬件资源也可能更少等等，这些都会导致软件的利润上升，所以上面的假定不成立。
这个质疑确实合理，我们不得不承认，一个好的设计确实会影响到最终的软件产品本身，现实中也确实如此。但是，别忘了我们已经假定了所有DFX需求，质量要求，性能要求是一样的，设计如果越差，就意味着必须投入更多的成本来达到各种DFX和质量需求。只不过现实中最终产品的质量好坏往往会随着团队能力，资源限制等等条件并不固定。

所以，如果固定好了其他因素，我们可以得出，软件设计影响的一定是**成本**，这应该是一个都能认同的结论。
但关于软件设计是如何影响成本的，可能会存在一些分歧。

### 3. 效率还是工作量？
在假定了所有条件都一样的情况，直接影响成本的因素只有时间。只要缩短时间，整个软件开发过程中的人力成本和非人力成本都会等比降低。而：
**时间 = 工作量 / 开发效率**

那么软件设计影响的要么是开发效率要么是工作量，也可以两者兼具。

关于工作量的定义，我们先看下软件行业对工作量的评估方式：
目前业内工作量的评估方式有以下几种：**专家评估法（WBS）**，**类比类推法**和**参数法（FPA）**。

这些方法本质上都是对历史数据进行加工，然后对当前事务的工作量进行“估算”。
WBS依靠的历史数据是专家的个人历史数据，类比类推依赖于过去同类项目的数据，FPA号称是最有效的软件测量方法，依靠的是整个行业的历史经验数据。

可见，整个行业的工作量评估都是没有专门考虑软件设计因素。不过这个也能理解，我们不可能在估算工作量的时候去考虑这个项目架师的水平，只能大致认为他与历史项目中的设计师水平相当，取一个平均值估算再为合理不过。
我个人并不反对这些评估工作量的方式，只是不能否认：**软件开发工作量的评估是忽略了软件设计的**。

所以，如果按照业内对工作量的评估方式，最终两个团队的工作量应该是不会存在区别的。似乎也应该如此，我们都已经假定了是完全相同的产品，功能点一样，DFX，质量要求都一样，工作量肯定是固定的，所以**软件设计影响的是效率**。

但真的如此吗？

笔者在刚毕业的时候待过一家外包公司，主要给XX公司做一些web管理平台，功能主要是一些配置数据的增删改查，后台也不涉及复杂的算法，仅仅是一些业务相关的校验。
由于项目都类似，所以公司的新项目都是直接拷贝旧项目的代码，并在这基础上进行修改。根据经验，新增一个页面从前到后大概3人天工作量。但是后来某个项目组（暂且叫项目组A）来了一个技术大牛，对代码进行了重构（因为业务主要是数据库的CRUD，进行了一些模板化处理），把这个工作量从3人天缩减到了1人天。假使项目组A不和其他团队进行任何交流，那么项目组A在评估工作量时会变成1人天一个页面，而其他所有团队却还是3人天一个页面，这永远也不会有人觉得奇怪，而且大家都觉得理所应当。

> 软件设计做得再差永远不会背锅：我们会奖励某人提升了多少效率，而会忽略效率本该如此。

这个例子给人的第一感觉好像是：**新来的技术大牛把团队的开发效率提了三倍**。但实际上却是我们在评估工作量时由3人天改成了1人天，这明明是工作量减少了三倍。
事实也确实如此：项目组A只是将大量的雷同代码抽象到了更高层，相同的一个页面代码量少了一半以上；尤其在维护阶段，新加一个数据库字段，以前要改十几个文件，而项目组A只需要改一处配置。而且后面实际统计出来也证明了这个结论（当时公司会每个月度统计开发人员的代码产出），项目组A的开发同学月产出代码并不比其他项目组的高。

其实深入思考一下，这个结果是必然的：
两个团队的人员素质相近，业务复杂度也基本一样，使用相同的技术栈，开发语言，开发工具和平台，单位时间写的代码肯定大致相同。
**好的软件设计并不能让某个程序员顿悟，瞬间提高他的有效代码产出。**

很显然，好的设计并不会**提高效率**，它只是**减少了工作量**。
看来，“好的软件设计能提高开发效率”是一个看起来很对但实际却站不住脚的结论。

一个良好的设计和糟糕的设计相比，在实现相同功能时代码量可能差一个数量级，这也正是软件设计的魔力所在，我们必须看清这个本质：
**软件设计改变的是工作量，而不是开发效率**。
> 笔者并不想说服所有人都认同这个结论，毕竟站在客户或者产品经理的角度看，最终的软件产品功能一样，他需要三天，你只需要一天，你的效率就是高一些。但作为码农，我们自己心里应该清楚，我们的编码效率并不会因为换了好的架构师就会有所提高，其实只是相同的功能需要的工作量少了。

> 笔者的职业生涯中经常在各种PPT上见过此类论述：我们通过使用新的框架和重新设计（解耦、重构和归一）提升了团队开发效率百分之多少多少，团队的效率从XXX行/人月提升到YYY行/人月，这种论调忽悠了很多领导。

### 4. 软件设计与复杂度

同样一个的程序员，假设一个月可以写一千行业务代码，但如果让他去写一个比较困难的算法，一个月肯定写不了一千行。
很明显，工作量不仅仅体现为代码行数，还与复杂度有关。

那么，我们说软件设计会影响工作量，除了影响代码行数，会不会影响到复杂度？
我个人认为，在一个固定的行业，软件设计对软件复杂度的影响甚微。因为**一个软件的复杂度，大部分都是由业务本身的复杂度决定的**。

软件开发本质是一种翻译工作，程序员将特定业务转化为对应的顺序，分支，循环和跳转语句即可，复杂的一定是业务本身，这也是在一个固定的行业可以通过有效代码行评估工作量和效率的原因。虽然一些特殊场景或行业下，比如3D建模软件，软件复杂度很高，但在大部分场景下我们的普通研发接触的都是常规业务，不会涉及到高难度技术问题或算法问题，而且我们所讨论的**软件设计**也不解决算法类的问题。

很多时候我们的直觉会认为好的软件设计会让代码变得简单，其实仅仅只是工作量变小的体现。
比如我们说一个模块太复杂了，修改代码完全无从下手，本质上这不是复杂，而是繁多。我们改一行代码，需要把很多历史代码读一遍（要知道读代码也是工作量），理清楚里面的逻辑，而这个**逻辑**本身就是业务逻辑。而好的设计会有更合理的解耦，每次修改会让改动聚集在一块更小的范围，最终会让人觉得简单。

关于软件设计是否影响复杂度，如果有不同意见，可以在文末通过邮箱与我交流讨论。但在我改变自己的想法前，暂且认为：
**软件设计只影响代码行数，并不影响复杂度**

### 5. 软件设计的度量

根据上面的讨论，如果我们要评价设计的好坏，只需要比较软件达到相同要求下在**整个生命周期内**花费的**总人力成本**（或所**需要的总工作量**）即可，而不是比较设计手段运用的如何高超，代码结构设计的如何优美。

可惜的是，这个结论很难在实际工作中进行落地，我们缺少对比的参照物。即使我们最终发现开发软件的实际工作量与预估的工作量相差甚远，也很难得出是软件设计很糟糕或很优秀之类结论，因为它很可能是下面的其他原因导致：
- 评估工作量出现失误
- 某个开发人员能力特别突出或特别糟糕
- 前期大量硬编码，后期维护带来大量工作量
- 需求变化

但唯独很难说是架构师很优秀或很糟糕。
要证明是由于架构师特别优秀导致节约了大量成本，或架构师能力太差导致工作量巨大都过于艰难。我们必须保证在相同条件相同背景而且能力完全相同的团队下换一种设计重新来过，而且还要一直等到软件的生命周期结束才能得以证明架构师存在的价值，而这是一件不可能完成的事情。实际中我们只能进行主观大致判断。

目前度量软件设计的工具有：structure101，inFusion，很多大厂内部也有一些专门度量设计的工具；大都是根据一些成熟的设计理论，计算函数的扇入扇出，根据类的引用次数计算依赖值等等，最终计算出一个量化值，用来衡量设计的好坏。

我个人觉得这些工具扫描出的设计缺陷是值得参考的，但是只能作为衡量当前代码与某些设计原则或模式的符合度，不能用于衡量软件设计的好坏。举一个例子，现在有一个**一锤子买卖**的项目，通过工具扫描代码的设计质量很差，耦合十分严重。我觉的这不见得是什么坏事，因为后期不再维护的项目，投入太多在可扩展性反而会成为浪费。这种时候，从结果看这种“差”反而是一种**好的设计**。

> 实际场景下，我们大部分的软件都是设计不足，生命周期也很长，需要长期维护，所以诸如inFusion之类的工具在大部分场景下对软件设计的评判仍然具有参考意义。

笔者非常佩服那些第一个提出想法而且付诸实施的先行者。同样，对于那些尝试量化软件设计好坏的个人或公司我也持有敬佩之心，毕竟一个事情如果不能量化，就代表着很难改进。但是对于量化软件设计这件事情本身，笔者是持悲观态度的，我更觉得美的软件设计偏向于一种艺术，架构师需要在不断的演化中，从理想和现实中寻找一个最佳的平衡点。就如“公式相声”根据观众笑的音量和时长量化“开心指数”，反推相声该如何讲一样，听起来很科学，但实际却行不通。
> “公式相声”只是用来比喻量化设计这个事情本身，但对从事这件事的个人和组织，笔者绝无羞辱之意。btw, 很多外行领导强行量化某些事情的行为和“公式相声”是真的如出一辙，这个我有表达羞辱。

笔者个人非常反对为了量化而量化的行为，有些领导唯数据论，强迫下面的人必须数据达标，而任何数据都是可以被程序员造出来的，尤其是软件设计在当前还没有比较好的量化工具的前提下。
> 很多大师在讲到什么是好的设计的时候，都会说没有最好的设计，而是喜欢用一些“恰到好处”，“刚刚好”，“合适”类似的词语，其实本质上正是对设计无法量化屈服后的无奈之言。笔者虽然没有更好的答案，但我知道，设计一定存在好坏之分（两种不同的设计导致的总人力成本一定不同），只是目前我们无法衡量，而且这种**刚刚好**的说法纯属耍赖，因为包括大师自己在内都没人可以讲清楚什么是**刚刚好**，这些词语只会让软件设计蒙上一层深不可测的哲学面纱，并无其他意义。

### 6. 总结

目前大部分软件设计相关的书籍都在鼓吹软件设计如何好，然后大篇幅的罗列各项原则或模式，但从未从本质上说明：什么是**好**。但是当你与他探讨设计模式好在哪里的时候，他确实会给你一些答案：你运用了这种设计模式，代码就开闭了，解耦了，可扩展性变高了。但当你有一天运用了设计模式，写了一块扩展性很强的代码的时候，又会突然冒出一个“大师”指着你的鼻子说：你这里**过度设计**了。如果我们和“大师”继续深入探讨，会发现最终一定会回到原点：**设计是基于业务本身的**。就好像最终只能凭借个人对于业务的理解来判断一个设计动作的好坏。
虽然我们并不一定要和谁争个你死我活，谁的设计水平更高，但至少做到心中有数。如果有一天别人对你的代码指指点点时，如果他讲不清楚所以然，你可以让他闭嘴，坚持你自己心中的好代码即可。

本书存在很多关于经典设计原则和23种设计模式的质疑，甚至是全盘否定；对于软件设计的理解，也存在与很多大众的理解背道而驰的地方；笔者查阅了大量关于设计原则和设计模式的博客，对于其中的讲解方式，重点以及作者本身的理解大都不太认同。
这并不是想证明笔者格外“出类拔萃”，亦或是“与众不同”，这只是一个码农对软件设计发自内心的思考：
开闭原则明显需要靠其他原则实现，而单一职责原则又明显包含接口隔离原则；设计原则的定义本身就不满足MECE原则，又如何抓住软件设计的核心和本质？
某些设计模式的代码如此雷同，明明是同一问题的不同表象，为什么要定义成两种模式；而有些设计模式完全与设计无关，完全不知道设计的“美”在哪里，为什么也能称之为一种“设计模式”？
> MECE分析法，全称 Mutually Exclusive Collectively Exhaustive，中文意思是"相互独立，完全穷尽"。具体意思是指能够将一个重要的议题分成若干个分类，这些分类之间没有重叠、没有遗漏，并且能够捕捉到问题的核心，并从中得到有效解决问题的方法。

关于本书的观点，各位读者尽可以保留自己的不同意见。但我希望各位读者是经过自己仔细思考候才持有的不同意见，而不是因为“设计原则”和“设计模式”久负盛名的权威。
**没有思考，只会沦落为设计原则和设计模式的复述者。**



### 参考文献

[1] 程博,于学军. 基于敏捷开发的工作量估算模型的研究[J]. 计算机工程与设计,2013,34(3):909-914. DOI:10.3969/j.issn.1000-7024.2013.03.032.

[2] 李明树,何梅,杨达,等.软件成本估算方法及应用[J].软件学报,2007,(4).775-795.

[3] 何晓阳,王亚沙.基于模型的软件成本估计方法[J].计算机研究与发展,2006,(5).777-783.

[4]《软件研发成本度量规范释义》王海青（北京软件造价评估技术创新联盟首席度量专家，北京科信深度科技有限公司CTO、首席度量专家）
