在前一章节，我们讨论了软件设计是通过减少工作量来达到节约成本的效果的。在讨论软件设计是如何减少工作量之前，我们不妨先看一个生活中的例子是如何减少工作量的。

现在我们要把一个包裹1号从A运送到B，包裹2号从C运送到D，需要雇佣一个跑腿的，跑腿的按时间收费。如果我们想少给点钱，会有什么办法？

给跑腿的搞辆车，提升他的移动效率。还有吗，好像不太能想出来，只能看下能不能有辆更快的车。

其实还有一种方法，但效果不会像车那么明显。我们可以看下AB和CD这两条路径是否有重合的地方，比如 A->X->Y->B，C->X->Y->D，那么我们可以让跑腿小哥先将包裹1号从A运送到X处，再将包裹2号从C运送到X处，然后将两个包裹一起从X运到Y处，再分别从Y运往B和D，有车没车我都能省点时间。

可以再多想几个例子，其实会发现，做任何一件事情，如果要降低成本，大致都有两类方法：

1. 技术革新（提高效率），但有门槛（车可不是随随便便就能发明出来的）；
2. 复用（减少工作量），无门槛，但存在上限（可复用的路线总长度）；

<br>人类社会任何一件事情的进步似乎总在技术革新和复用两者间螺旋式上升。发明了印刷术后，我们又发明了活字印刷术，从本质上来说，印刷术是一种技术革新，而活字印刷术只是在新技术上做了一些复用改进。

软件设计其实正是通过一些朴实无华的“复用”手段减少工作量的，并非多么高明的技巧，只是软件中的重复并不会像路线重叠那样显而易见，有些时候需要我们自己去创造和发现，仅此而已。

和生活中的复用一样，软件设计也有以下特点：

1. 软件设计天然存在上限：如果我们将所有可复用的地方都复用了，软件设计的作用就发挥到极限了。(让开发人员只需关注业务本身)
2. 软件设计不属于技术革新，只是一种普遍实践经验，未来也不太可能会有理论上的革新或进化。
3. 软件设计没有技术门槛（不会被卡脖子），任何普通人通过学习都可以将它稍加变形运用在任何行业上。


虽然本书我要讲的是软件设计，软件设计也确实很重要，但必须承认，软件设计存在它的天然局限性：
- 在低效的语言上将设计模式运用的天花乱坠，永远也比不上发明一种更高效的语言或新技术；正如用人的两条腿跑路，无论你如何设计路线，永远也比不上电动车无脑送货；
- 但是，无论多么高级的语言和多么新的技术，都可以在其基础上通过恰当的运用软件设计再进一步提高收益。正如无论多么快的交通工具，也都可以通过规划和设计路线让时间再缩短一些。

**设计没有未来，但永不过时。**
> 自从1995年GoF的《设计模式》出版后，软件设计的理论基本没有革新过，时而有一两本新书，但都是基于设计原则和模式的二次理解（包括本书也是）。当然，我们也可以说软件设计理论从来就没有改变过，它一直在那，只是刚好1995年出了一本比较经典的书籍。我相信未来很长时间内也不会有新的软件设计理论出现，只会出现一些新的理解，换汤不会换药。


### 1. 复用

程序员的主要工作是写代码，也会读代码。要有效的减少工作量，主要通过两种方式：
1. 少写代码：复用以前写过的代码；
2. 少读代码：让程序员避免重复理解之前的业务逻辑和历史代码；


#### 1.1 共用

想少些代码，最简单的方式是共用一些代码，写过的就不要再写了，比如我们常见的工具类。这种复用一段公共代码的方式我们称之为“共用”，这也是**复用**最基本最简单的一种方式。

以前出版书籍最开始都是靠手抄，后来科技进步，出现了印刷术，可以用印刷代替手抄，效率飙升。但是这样会有个问题，就是每出一本新书的时候，都要重复刻板子，工作量巨大。于是又出现了活字印刷术，活字印刷术并不是技术上的创新，只是一个简单的复用技巧，把所有常见的字都刻几份，通过组装字块到一块板子里进行印刷，这样每次出新书就可以复用这些字块，不用重新刻板子了。另外，由于字块过于分散每次拼板子也有点费时，于是便把一些常用的词语合起来做成一个大的字块，这样找字块和拼字块的效率会略高一些。

软件上的共用也是如此。有时候一个公共函数太大，会发现其中仍然还有可共用的代码，则需要再拆；而如果公共函数都拆的很小，很可能每个地方都需要调用好几个公共函数才能完成业务逻辑。
- 拆解的粒度过小，复用起来会略显困难。
- 拆解的粒度过大，可复用性会略有降低。

总的来说，我们需要将代码拆解到合适的粒度进行共用，有必要的话还可以增加分层，让一个大的公共函数套几个小的公共函数。

#### 1.2 稳定复用
想少读代码，则主要依靠开闭原则，尽量在改bug，加需求的时候尽可能少的影响历史代码。软件的这种特性，我们常常称之为“可扩展性”。

其实“可扩展性”并不是软件设计追求的最终目的。
为了让代码具有“可扩展性”，我们往往会增加额外的抽象接口或者中间层，其实是会额外投入一些成本的；而且最终“可扩展性”强的代码也并不会让我们在增加需求的时候少写代码。
让软件具有“可扩展性”最核心的目的其实是“隔离变化”：让修改的代码尽量集中，尽可能避免修改历史代码————这本质上是一种“读复用”。
要知道历史代码一定是被某位前辈程序员理过一遍业务逻辑并写过一遍的，如果换了程序员，或者时间隔了很久，突然要修改它，那么必定导致这里的业务逻辑要重新梳理一遍，可能正因为一次次的修改，这里的代码要重复的一遍一遍被读和被理解。

而且在很多时候：**改是质的问题，改多少是量的问题**
对于一个设计糟糕的系统/模块/类来说，即使只修改一行代码，代表着你大概率需要重新梳理大量与之相关的历史代码，然后精准的找到这行代码的修改之处。修改完之后再进行重新编译，打包，测试，部署等等，整体工作量往往比想象中的庞大。

> 在实际项目中，常见的表现是：一个很小的业务改动，会引起大范围改动或者改动困难。主要原因是各模块/类纠缠不清，耦合严重（代码僵硬）。最终即使修改的总代码行也不太多，但由于我们需要理清很多历史逻辑，导致最终花费的工作量很多。
> 所以，我们通过设计，改变两个模块的依赖关系，让一部分模块和代码达到稳定复用，让改动控制在比较小的范围，尽量减少我们的工作量。

<br>在本书中，我们将这种在需求不断更迭的情况下依然能保持稳定且不用修改的特性称之为“稳定复用”。
稳定复用注重的是发生变化时的“读复用”，而且**能稳定复用的代码一般都能共用**，所以通常情况下它不仅能让我们在维护阶段少读代码，也能少写代码。

“稳定复用”的前提依然是拆解，毕竟只有先将一个事务拆开成两个，才能进行“隔离”。

> 因为让代码“可扩展”是需要投入额外成本的，如果这种“可扩展性”并没有起到实际效果，会造成我们常说的“过度设计”。比如我们做了一些隔离，发现需求变化的方向与我们预期不符，最终这里即使不做隔离也没有影响，会造成一些浪费。尤其对于一些有代码洁癖的人，这种浪费会经常发生，他们在编写代码的时候习惯会对未来预留一些扩展，但一旦与预期不符，就出现了“过度设计”。笔者认为，轻微的“过度设计”是完全可以接受的，只有不做设计的人才永远不会过度设计！但如果总是出现大量“过度设计”，那么我们应该引起重视，看下自己的设计理念是否存在一些问题，加以纠正即可。

> 如果严格地说，软件设计的本质是追求“有效复用”。

### 2. 拆解——复用的前提

举个例子，假设有如下代码:
```
public static void setUrl(SipRequest request, String str) {
    String url = null;

    /**
     * 一段解析str的代码, 并将结果赋值给request的url属性;
     */
    // some code

    request.setUrl(url);
}
```
大致逻辑是，str是一个url，需要进行一些解析或校验，然后赋值给SipRequest的url属性；如果现在有个HttpRequest也要做相同的处理，该怎么办?
由于HttpRequest和SipRequest没有共同的基类（而且我们也不能修改他们的源码让他们继承同一个接口或基类），那么我们只能再写一个函数：
```
public static void setUrl(HttpRequest request, String str) {
    String url = null;

    /**
     * 一段解析str的代码, 并将结果赋值给request的url属性;
     */
    // some code

    request.setUrl(url);
}
```
其实这段解析url的代码是完全相同，如果想要共用，我们需要拆解这两个函数，独立出一个公共函数：
```
public static String parseUrl(String str) {
    String url = null;
    
    /**
     * 一段解析url的代码, 并将结果赋值给url;
     */
    // some code
    
    return url;
}
```
调用的地方直接写成这样既可:
`request.setUrl(parseUrl(str));`

> 最开始的setUrl函数本身就是有问题的，他做了SipRequest的setUrl和解析url两个事情，这种写法会让函数难以复用。实际工作中，很多人都会犯此种错误，其中不乏一些常年将设计理论挂在嘴边的老程序员，很可能都是由于对面向对象的软件设计理解不够深刻导致。同样，对于那些代码写的非常优雅的优秀程序员，即使没有看过任何设计类的书籍，但骨子里已经对软件设计有了自己的理解。

<br>可以看出，我们要复用一段代码，必须先将原有逻辑拆解到可复用的程度才行。
无论是共用还是稳定复用，都是建立在拆解的基础上的。整个过程可以简单分为两步：

**拆解（分）**：将一个大的模块拆解成多个独立的小模块

**复用（治）**：共用相同的模块，或通过解耦让其中部分模块可以稳定复用。



**拆解是复用的前提；复用是拆解的目的。**

拆解的好坏也直接决定了可复用的上限。拆解是评价架构师水平的第一标准，也是软件设计领域最为重要也最困难的概念。
除了设计师本身的技术能力和经验外，拆解的好坏还与业务强相关。所以，一个优秀的设计师必须对本领域的业务有非常深刻的理解。

> 拆解是一项必须经过长时间(数年甚至数十年)的实践才能得以熟练掌握的一项技巧，而且有时候还需要一点“悟性”。

#### 3. 总结
**软件设计的本质是复用**

我们很确定的是使用设计原则，或设计模式，抑或是多么高明的设计手段并不能提高开发人员的生产效率，软件设计能做的只能是通过朴实的“复用”来减小工作量：要么少写一些写过的代码，少读一些之前的历史代码。
我们经常挂在嘴边的“高内聚低耦合”，“抽象”、“可扩展性”，“开闭”都只是软件设计所追求的表面现象，如果最终不能有效复用，这些所谓的“灵活性”毫无意义，它们的本质都是为了最基本的“复用”。
