在讨论软件设计本质前，我们不妨先讨论另外一个问题，我们在日常生活中是如何减少工作量的？

现在我们要把一个包裹1号从A运送到B，包裹2号从C运送到D，需要雇佣一个跑腿的，跑腿的按时间收费。如果我们想少给点钱，会有什么办法？

给跑腿的搞辆车，提升他的移动效率。还有吗，好像不太能想出来，只能看下能不能有辆更快的车。

其实我们可以看下AB和CD这两条路径是否有重合的地方，比如 A->X->Y->B，C->X->Y->D，那么可以让跑腿小哥先将包裹1号从A运送到X处，再将包裹2号从C运送到X处，然后将两个包裹一起从X运到Y处，再分别从Y运往B和D，有车没车我都能省点时间。

可以再多想几个例子，其实会发现，做任何一件事情，如果要降低成本，只有两类方法

1. 技术革新（提高效率），但有门槛（车可不是随随便便就能发明出来的）；
2. 复用（减少工作量），无门槛，但存在上限（可复用的路线总长度）；

人类社会任何一件事情的进步似乎总在技术革新和复用两者间螺旋式上升。发明了印刷术后，我们又发明了活字印刷术，从本质上来说，印刷术是一种技术革新，而活字印刷术只是在新技术上做了一些复用改进。

软件设计其实正是通过一些朴实无华的“复用”手段减少工作量的，并非多么高明的技巧，只是软件中的重复并不会像路线重叠那样显而易见，有些时候需要我们自己去创造和发现，仅此而已。

所以，回到本篇最初的问题：如果要用一个词对这些原则和模式进行概括，便是：
***复用***



理所当然，软件设计会有以下特点：

1. 软件设计天然存在上限：如果我们将所有可复用的地方都复用了，软件设计的作用就发挥到极限了。(让开发人员只需关注业务本身)
2. 软件设计不属于技术革新，只是一种普遍实践经验，未来也不太可能会有理论上的革新或进化。软件设计没有技术门槛（不会被卡脖子），任何普通人通过学习都可以将它稍加变形运用在任何行业上。



虽然本书我要讲的是软件设计，软件设计也确实很重要，但必须承认，软件设计存在它的天然局限性：
- 在低效的语言上将设计模式运用的天花乱坠，永远也比不上发明一种更高效的语言或新技术；正如用人的两条腿跑路，无论你如何设计路线，永远也比不上电动车无脑送货；
-  但是，无论多么高级的语言和多么新的技术，都可以在其基础上通过恰当的运用设计技巧再进一步提高效率。正如无论多么快的交通工具，也都可以通过规划和设计路线让时间再缩短一些。

**设计没有未来，但永不过时。**
> 自从1995年GoF的《设计模式》出版后，软件设计的理论基本没有革新过，时而有一两本新书，但都是基于设计原则和模式的二次理解（包括本书也是）。当然，我们也可以说软件设计理论从来就没有改变过，它一直在那，只是刚好1995年出了一本比较经典的书籍。我相信未来很长时间内也不会有新的软件设计理论出现，只会出现一些新的理解，换汤不会换药。


### 1. 复用

程序员的主要工作是写代码，也会读代码，而且读代码占比会远高于写代码的时间，因为对于大部分产品来说维护周期往往很长，我们需要花费大量时间阅读历史代码来修复bug，增加新需求等等。
据统计，程序员平均会花费80%以上的时间在理解历史代码上。（数据来源于非官方渠道，但根据笔者经验认为这个结论大致准确）

要有效的减少工作量，主要通过两种方式：
1. 少写代码：复用以前写过的代码；
2. 少读代码：让程序员避免重复理解之前的业务逻辑和历史代码；

这也对应着复用的两种方式：**共用**和**稳定复用**

#### 1.1 共用

当讲到复用的时候，最容易让人想到的就是**共用**。这确实是**复用**最基本的一种方式。

以前出版书籍最开始都是靠手抄，后来科技进步，出现了印刷术，可以用印刷代替手抄，效率飙升。但是这样会有个问题，就是每出一本新书的时候，都要重复刻板子，工作量巨大。于是又出现了活字印刷术，活字印刷术并不是技术上的创新，只是一个简单的复用技巧，把所有常见的字都刻几份，通过组装字块到一块板子里进行印刷，这样每次出新书就可以复用这些字块，不用重新刻板子了。另外，由于字块过于分散每次拼板子也有点费时，于是便把一些常用的词语合起来做成一个大的字块，这样找字块和拼字块的效率会略高一些。

软件上的共用也是如此，我们需要将板子先拆成一个一个字块才能复用，拆的太分散使用起来又会略显困难，所以：
**我们必须将代码块拆解到合适的粒度进行复用**。
- 拆解的粒度过小，复用起来会略显困难。
- 拆解的粒度过大，可复用性会略有降低。


#### 1.2 稳定复用

稳定复用主要指的是时间维度上的复用。比如一个模块或类，1.0版本发布，当后续需求不断变更后我们发布2.0，3.0版本该模块依然不需要任何改动。我们将这种模块或类保持稳定的特性称之为**稳定复用**。

在实际项目中，**稳定复用**产生的作用远比**共用**产生的作用明显。常见的表现是：一个很小的业务改动，会引起大范围改动或者改动困难。主要原因是各模块/类纠缠不清，耦合严重（代码僵硬）。最终即使修改的总代码行也不太多，但由于我们需要理清很多历史逻辑，导致最终花费的工作量却不少。

而且在很多时候：**改是质的问题，改多少是量的问题**
对于一个设计糟糕的系统/模块/类来说，即使只修改一行代码，代表着你大概率需要重新梳理大量与之相关的历史代码，然后精准的找到这行代码的修改之处。修改完之后再进行重新编译，打包，测试，部署等等，整体工作量往往比想象中的庞大。

所以，我们通过设计，改变两个模块的依赖关系，让一部分模块和代码达到稳定复用，让改动控制在比较小的范围，尽量减少我们的工作量。

稳定复用注重的是发生变化时的复用，它能让我们在维护阶段少读代码和少写代码，而且**能稳定复用的代码一般都能共用**。

### 2. 拆解——复用的前提

举个例子，假设有如下代码:
```
public static void setUrl(SipRequest request, String str) {
    String url = null;

    /**
     * 一段解析str的代码, 并将结果赋值给request的url属性;
     */
    // some code

    request.setUrl(url);
}
```
大致逻辑是，str是一个url，需要进行一些解析或校验，然后赋值给SipRequest的url属性；如果现在有个HttpRequest也要做相同的处理，该怎么办?
由于HttpRequest和SipRequest没有共同的基类，我们只能再写一个函数：
```
public static void setUrl(HttpRequest request, String str) {
    String url = null;

    /**
     * 一段解析str的代码, 并将结果赋值给request的url属性;
     */
    // some code

    request.setUrl(url);
}
```
其实这段解析url的代码是完全相同，如果想要共用，我们需要拆解这两个函数，独立出一个公共函数：
```
public static String parseUrl(String str) {
    String url = null;
    
    /**
     * 一段解析url的代码, 并将结果赋值给url;
     */
    // some code
    
    return url;
}
```   
调用的地方直接写成这样既可:
`request.setUrl(parseUrl(str));`

>最开始的setUrl函数本身就是有问题的，他做了SipRequest的setUrl和解析url两个事情，这种写法会让函数难以复用。实际工作中，很多人都会犯此种错误，其中不乏一些常年将设计理论挂在嘴边的老程序员，从本质上说这都是对面向对象编程或对软件设计理解不够深刻导致。同样，对于那些代码写的非常优雅的优秀程序员，即使没有看过任何设计类的书籍，但骨子里已经对软件设计有了自己的理解。


可以看出，我们要复用一段代码，必须先将原有逻辑拆解到可复用的程度才行。
无论是共用还是稳定复用，都是建立在拆解的基础上的。整个过程可以简单分为两步：

**拆解（分）**：将一个大的模块拆解成多个独立的小模块

**复用（治）**：共用相同的模块，或通过解耦让其中部分模块可以稳定复用。



**拆解是复用的前提；复用是拆解的目的。**

拆解的好坏也直接决定了可复用的上限。

拆解是评价架构师水平的第一标准，也是软件设计领域最为重要也最困难的概念。

> 拆解是一项必须经过长时间(数年甚至数十年)的实践才能得以熟练掌握的一项技巧，这也是大部分人即使看完所有的设计理论书籍也成不了设计大师的根本原因。
除了设计师本身的技术能力和经验外，拆解的好坏还与业务强相关。所以，一个优秀的设计师必须对本领域的业务有非常深刻的理解。


### 3. 总结

**软件设计的本质是复用**

当真正理解设计的本质是复用后，很多设计领域的理论都可以很好的被解释：

**分治理论**：先分后治，先拆解后复用，按层递归分治。

**过度设计**：提前拆解（解耦）或增加中间层，最终没有复用(不需要复用)，浪费工作量。

**不要被一颗子弹击中两次**：在看不准业务发展的情况下，暂且不做拆分，等到出现可复用情况，再来重构，这样并不会造成多大的工作量损失。

**隔离变化**：对稳定模块和不稳定模块进行解耦，将不稳定模块的变化影响隔离在外，让稳定模块可复用。
