抽象是软件设计的灵魂。
所以在分析设计原则之前，我们先讨论一下**抽象**。


### 1. 什么是抽象

关于“抽象”我没有找到特别恰当的解释，于是笔者尝试自己定义了一个：
抽象：根据业务关注点，对一类事物剥离个性，归纳共性的过程。

抽象，有时候是动词，有时候是名词，有时还是形容词。
作为动词时，代表抽象的过程；作为名词时，代表抽象这个动作的结果；而作为形容词时，讲的其实是抽象的程度；
一般根据上下文，我们都能很轻易的辨别其想表达的意思。


### 2. 抽象的关注点

我们如果要完整的描述一个具体的人，应该是一件不可能做到的事情：
一个具体的人的物理结构本身已经复杂无比：身体分为多个部位；每个部位又由无数个细胞组成；细胞又可以分成原子；原子又分为粒子；粒子又分为夸克；如果人类的认知范围继续扩大，应该还可以再分下去。而这些组成部分，对一个具体的人来说，都是独一无二的。除了物理组成，还有人的社会关系，经历等等。而且所有的这些属性还在时间维度下持续变化。
即使我们可以收集到一个人所有与之相关的信息，也没有办法存储，地球上所有的存储介质加起来也不够。

好在没有任何场景是需要如此完整的描述一个具体的人的，往往我们只需要提取出我们所关注的特性即可。

对于一个物流系统来说，一个人只是包含地址，电话，姓名的组合而已，动作属性则是寄信收信；而对于一个婚恋网站而言，一个人则是性别，年龄，身高，职业，年收入，是否再婚的组合，动作属性则主要包含聊天，送礼等行为。
钱对于银行的印刷系统来说，有版号，编号，面额，批次，印刷日期等属性；但是对于一个电商系统而言，它连对象都不算，只是个没有感情的数值。

当我们将一个人描述为一组属性和行为的组合时，这个过程便是抽象，而最终这个系统中关于人的定义，就是抽象的结果。这个定义，是对一类事物的归纳描述，并不包含某个具体个人的信息，每个人都有这些属性，但各不相同。

#### 关注点的拆分
在上面的例子中，似乎划分属性和行为的过程特别简单，就像我们把人的身体分为头，身体和手一样；它们的划分界限过于明显，我们会很自然的把人的身体分为这几个部分，好像理所当然一般。但实际工作中，越到细节处越难以区分。
比如我们将人的头部划分了嘴巴，鼻子，耳朵等模块，现在需要实现一个呼吸功能，那么我们应该将这个功能放在哪个模块中才合适？
有人会认为放在鼻子中，但是如果鼻子塞住了，其实我们可以用嘴巴呼吸。如果深入了解，我们会发现鼻子和嘴巴只是提供呼吸的接口而已，呼吸的具体实现应该放在肺这个模块中。

在软件实现层面，一个对象应该有多少个属性，有多少个方法；具体的一个属性、一个方法应该如何定义，定义在哪其实都并非一件容易的事。

> 在实际工作中，如果没有做好抽象，会导致子系统、模块或类的定义不清，最终多个团队会因为一个特性该由谁做而争执不休。

### 3. 抽象的层次
抽象是分层次的，而且越庞大的系统，层次会越多。

比如描述一个人的身体结构，我们在第一层可能会分为：头部，身体和四肢；第二层则会把四肢分为左手，右手，左腿，右腿；第三层则会把左手分为大臂，小臂，手肘和手掌；第四层手掌可以分为大拇指，食指，中指，无名指，小指和掌心。
一个大的电商系统，一定会先分为若干个子系统，比如用户管理系统，商品管理系统，支付系统，物流系统等等；每个子系统又再分为多个子模块；最终是一些高层抽象的类，下面是一些低层抽象的类，最终到一个一个代表行为的函数。

即使到了代码层面，依然存在层次关系。将不同层次的代码放在一个函数中，是我们常犯的一种错误。比如使用伪代码模拟笔者写这本书的过程：
```
void 写书() {
	撰写目录
	撰写前言
	撰写第一章
	撰写第二章
	撰写第三章
	撰写结语
}
```

尽管每一个章节的内容要比目录，前言和结语要多很多，但这仍然不能影响他们的层次高低关系。就像我们不能根据部门大小和人数来决定两个部门经理的行政地位一样。
很明显，“正文”才是和目录，前言，结语相同层级的抽象。所以代码写成如下才是合理的：
```
void 写书() {
	撰写目录
	撰写前言
	撰写正文
	撰写结语
}

void 撰写正文() {
	撰写第一章
	撰写第二章
	撰写第三章
}
```
> 试想一下，当笔者想再写一本新书的时候，而新书比原来多了一章。前者我们需要修改写书这个函数，而后者只需要修改撰写正文这个函数。在工作量上两者似乎差别不大，但从复用性上看，前者无法复用，而后者至少写书这个函数是可以复用的。在一个大的系统中，层次划分的合理与否可以决定一个模块能否复用。

将不同层次的东西放到了同一个代码层面进行处理的这种行为，我们称之为“越级”。
一个系统的层次越高的抽象就应该越稳定的，它是设计师需要捍卫的边界，不到万不得已，我们不应去打破这个边界。

### 4. 抽象的高度

抽象的高度和抽象的层次是两个完全不同的概念，但是又非常容易混淆，甚至很多时候我们都没有加以区分。如果有人说一个抽象有点高，一般表达的都是高度太高，有时候需要结合上下文，才能搞清楚他说的是层次还是高度。

高度更高的抽象，是剥离了更多的个性的表现，这也使得更高的抽象往往能容纳更多的事物；
比如张三，我们可以将他抽象成一个人：会说话，会走路，有身份证号，年龄属性；人这个概念剥离了张三的个性；
我们还可以将张三抽象成动物：会发出声音，会移动，有年龄属性；动物不仅剥离了张三的个性，还剥离了人的一些特殊属性；
甚至，我们还可以将张三抽象成生物：可能就只剩下活着还是死了这一个状态属性了；生物则进一步把动物的一些个性行为也剥离了；

> 抽象的层次，描述的是组合关系，比如军队和士兵，公司和员工；抽象的高低，描述的是继承关系，比如动物和人，人和张三；

更高的抽象，包容性会更好。依赖倒置原则所说的面向抽象编程，正是因为抽象的包容性。
但是并不是让函数依赖更高的抽象就越好，因为抽象越高意味着剥离了更多的个性，导致函数可实现的功能就越有限。

比如一个函数依赖“人”这个抽象，那么它可以兼容张三，李四各种具体的人，但是没法包容其他动物；
如果它依赖于“动物”这个抽象，那么这个函数不仅可以给张三，李四使用，还可以供各种阿猫阿狗使用；这样明显会让函数更具兼容性和扩展性。
但是如果我们继续将抽象拔高到生物，这个函数便无法实现了，毕竟植物没有走路这个方法。
```
// 可以传递张三、李四等人的具体实例对象
public void method(Person person) {
    // some code
	...
	
	person.walk();
	
	// some coe
	...
}

// 抽象更高，可以将阿猫阿狗作为参数传入
public void method(Animal animal) {
    // some code
	...
	
	animal.walk();
	
	// some coe
	...
}

// 生物不一定都有walk这个方法，导致函数无法实现
public void method(Biological biological) {
    // some code
	...
	
	// ？？？
	biological.walk();
	
	// some coe
	...
}
```

所以在相应的抽象层级，我们只能实现相对应的功能；而涉及到具体业务的功能，由于在高层抽象层中无法实现则会下移到业务模块中。


这里有一个比较设计的业务场景，比如一个卖桃子的老板希望我们帮他做一个软件：每天统计一下自己卖了多少钱的桃子。

1. 抽象过低（完全不做抽象）：

   直接按照老板的需求，迅速的开发出一个软件，只需要每个顾客来买桃子，填上对应的斤数就可以了，系统后台自动乘以单价然后累加金额就好了。 

   这个软件对桃子老板来说确实好用，拿来即用。但是坏处也特别明显，桃子单价变了，软件就得升级；卖其他水果或多种水果的老板也没法用，更不用说小卖部和商超。

2. 适当抽象：
   从老板的业务来看，主要有商品（包含名称，单价等属性），还有交易（买的什么商品，买了多少，总金额）两个实体，这样抽象后做出来的软件，我们发现至少一些小商贩都可以用了，但是前提是他们得预先录入一些商品和价格信息。这时桃子老板还能接受，毕竟就录入桃子就好了。

3. 抽象过高：
   我们想一劳永逸做一款无所不能的软件，这样，我们不仅可以给桃子老板用，还可以卖给加油站老板，出租车公司，政府单位。于是我们经过很久的思考，觉得所有这些业务的共性都无外乎是：数据+流程（操作）；于是我们开发了一个支撑各种数据定义，以及各种循环，判断，分支等流程语法的软件。当我们把这款软件交给桃子老板时，老板就骂街了：因为我们给他的是一个JDK，产品文档是java开发手册，他要做的事情是配置一堆代码完成他想要的功能。

我们可以通过这个例子看出一些规律：
- 抽象过低的前期工作量最小，而且对于客户来说使用最方便，但一旦业务场景扩张或者需求开始膨胀，过低抽象的短板开始体现，最终可能需要给每个客户定制一个软件。
- 适当抽象的前期工作量略大，在客户界面需要进行一些个性化配置；但是由于抽象带来的可扩展性，在业务场景扩张和需求变更时，受冲击的影响较小，最终的总工作量会远小于不做抽象。
- 抽象太高的前期工作量极大，对于非专业人士来说使用起来极为困难；反之其带来的好处是极为灵活，如果业务场景和需求并没有按照预期进行扩张，会造成前期的工作量浪费；而且一旦抽象过头甚至可能会失去意义（过高的抽象虽然灵活，但由于抛弃了过多的个性，导致这些个性逻辑会下沉到业务模块中，毕竟我们不可能真的将JDK交给客户，有时候**什么都能做等于什么都不能做**）


总的来说：
- **抽象的层次越高 -> 相对趋向于灵活、稳定、易复用但难以应用**
- **抽象的层次越低 -> 相对趋向于僵硬、异变、难复用但容易应用**

抽象的高度不宜过高，也不宜过低；在高度相差较大的抽象层中间我们往往会增加一些中间抽象和模块，比如在生物和张三之间，保留动物，人这两层抽象；

而无论怎样，软件设计总是会陷入这种两难的境地：
- 向左是不做抽象————设计薄弱，丢失扩展性，后期业务扩展需要投入巨大人力；
- 向右是抽象过高————过度设计，前期投入多，后期如果未有效复用则形成浪费；

所以又回到了耍赖的阶段：最好的抽象是“刚刚好”。下面这段话来自于Uncle Bob，比较能表达什么是“刚刚好”：


**根本不存在充分分析这种东西，无论花多少时间试图去找出完美的软件结构，客户总是会引入一个变化破坏这个结构。这种情况是无法避免的，不存在完美的结构，只存在试图去平衡当前的代价和收益的结构。随着时间的过去，这些结构肯定会随着需求的改变而改变，管理这种变化的诀窍是尽可能的保持系统的简单灵活。**
                                      ——摘自bob大叔《敏捷软件开发 原则、模式与实践》
									  
> 抽象的高度是一个相对概念，这里会存在一个误区，很多人认为只有接口和抽象来才是抽象，其实不然，连最基本的int类型相对于整数1,2,3来说也是抽象。

### 5. 总结

抽象是所有设计原则的基础，而设计原则又是所有设计模式的基础。

任何两个事务都可以抽象到同一个概念上来：java的Object类就是所有对象的顶级抽象，而由于java中的函数并非对象，使用了类似于Callable, Runnable等接口作为函数的顶级抽象；