抽象是软件设计的灵魂。
所以在分析设计原则之前，我们先讨论一下**抽象**。


### 1. 什么是抽象

关于“抽象”我没有找到特别恰当的解释，于是笔者尝试自己定义了一个：
抽象：根据业务关注点，对一类事物剥离个性，归纳共性的过程。

抽象，有时候是动词，有时候是名词，有时还是形容词。
作为动词时，代表抽象的过程；作为名词时，代表抽象这个动作的结果；而作为形容词时，讲的其实是抽象的程度；
一般根据上下文，我们都能很轻易的辨别其想表达的意思。


### 2. 抽象的关注点

我们如果要完整的描述一个具体的人，应该是一件不可能做到的事情。
一个具体的人的物理结构就已经复杂无比：身体分为多个部位；每个部位又由无数个细胞组成；细胞又可以分成原子；原子又分为粒子；粒子又分为夸克；如果科技不断进步，应该还可以再分下去。而这些组成部分，对一个具体的人来说，都是独一无二的。除了物理组成，还有人的社会关系，经历等等。而且所有的这些属性还在时间维度下持续变化。
即使我们可以收集到一个人所有与之相关的信息，也没有办法存储，地球上所有的存储介质加起来也不够。

好在没有任何场景是需要如此完整的描述一个具体对象的，往往我们只需要提取出我们所关注的特性即可。

对于一个物流系统来说，一个人只是包含地址，电话，姓名的组合而已；而对于一个婚恋网站而言，一个人则是性别，年龄，身高，职业，年收入，是否再婚的组合。
钱对于银行的印刷系统来说，有版号，编号，面额，批次，印刷日期等属性；但是对于一个电商系统而言，它连对象都不算，只是个没有感情的数值。

当我们将一个人描述为地址，电话，姓名的组合时，这个过程便是抽象，而最终这个系统中关于人的定义，就是抽象的结果，也是我们关注点的体现。这个定义，是对一类事物的归纳描述，并不包含某个具体个人的信息，每个人都有这些属性，但各不相同。


### 3. 抽象的层次
抽象是分层次的，而且越庞大的系统，层次会越多。

比如描述一个人的身体结构，我们在第一层可能会分为：头部，身体和四肢；第二层则会把四肢分为左手，右手，左腿，右腿；第三层则会把左手分为大臂，小臂，手肘和手掌；第四层手掌可以分为大拇指，食指，中指，无名指，小指和掌心。
一个大的电商系统，一定会先分为若干个子系统，比如用户管理系统，商品管理系统，支付系统，物流系统等等；每个子系统又再分为多个子模块；最终是一些高层抽象的类，下面是一些低层抽象的类，最终到一个一个代表行为的函数。

即使到了代码层面，依然存在层次关系。将不同层次的代码放在一个函数中，是我们常犯的一种错误。比如使用伪代码模拟笔者写这本书的过程：
```
void 写书() {
	撰写目录
	撰写前言
	撰写第一章
	撰写第二章
	撰写第三章
	撰写结语
}
```

尽管每一个章节的内容要比目录，前言和结语要多很多，但这仍然不能影响他们的层次高低关系。就像我们不能根据部门大小和人数来决定两个部门经理的行政地位一样。
很明显，“正文”才是和目录，前言，结语相同层级的抽象。所以代码写成如下才是合理的：
```
void 写书() {
	撰写目录
	撰写前言
	撰写正文
	撰写结语
}

void 撰写正文() {
	撰写第一章
	撰写第二章
	撰写第三章
}
```

将不同层次的东西放到了同一个代码层面进行处理的这种行为，我们称之为“越级”。

一个系统的层次越高的抽象就应该越稳定的，它是设计师需要捍卫的边界，不到万不得已，我们不应去打破这个边界。

### 4. 抽象的高度

抽象的高度和抽象的层次是两个完全不同的概念，但是又非常容易混淆，甚至很多时候我们都没有加以区分。如果有人说一个抽象有点高，一般表达的都是高度太高，有时候需要结合上下文，才能搞清楚他说的是层次还是高度。

高度更高的抽象，是剥离了更多的个性的表现，这也使得更高的抽象往往能容纳更多的事物；
比如张三，我们可以将他抽象成一个人：会说话，会走路，有身份证号，年龄属性；人这个概念剥离了张三的个性；
我们还可以将张三抽象成动物：会发出声音，会移动，有年龄属性；动物不仅剥离了张三的个性，还剥离了人的一些特殊属性；
甚至，我们还可以将张三抽象成生物：可能就只剩下活着还是死了这一个状态属性了；生物则进一步把动物的一些个性行为也剥离了；

> 抽象的层次，描述的是组合关系，比如用户管理系统和用户，公司和员工；抽象的高低，描述的是继承关系，比如动物和人，人和张三；

更高的抽象，包容性会更高。依赖倒置原则所说的面向抽象编程，正是因为一个抽象的接口能包容更多的事物。
一个函数依赖“人”这个抽象，那么它可以兼容张三，李四各种具体的人，但是没法兼容其他动物；
如果它依赖于“动物”这个抽象，那么我们不仅可以兼容张三，李四，还可以兼容各种阿猫阿狗；这样明显会更具兼容性和扩展性，但是仍然没法兼容花花草草；


举个例子，比如一个卖桃子的老板希望我们帮他做一个软件，就是每天统计一下自己卖了多少钱的桃子。

1. 抽象过低（完全不做抽象）：

   直接按照老板的需求，迅速的开发出一个软件，只需要每个顾客来买桃子，填上对应的斤数就可以了，系统后台自动乘以单价然后累加金额就好了。 

   这个软件对桃子老板来说确实好用，拿来即用。但是坏处也特别明显，桃子单价变了，软件就得升级；卖其他水果或多种水果的老板也没法用，更不用说小卖部和商超。

2. 适当抽象：
   从老板的业务来看，主要有商品（包含名称，单价等属性），还有交易（买的什么商品，买了多少，总金额）两个实体，这样抽象后做出来的软件，我们发现至少一些小商贩都可以用了，但是前提是他们得预先录入一些商品和价格信息。这时桃子老板还能接受，毕竟就录入桃子就好了。

3. 抽象过高：
   我们想一劳永逸做一款无所不能的软件，这样，我们不仅可以给桃子老板用，还可以卖给加油站老板，出租车公司，政府单位。于是我们经过很久的思考，觉得所有这些业务的共性都无外乎是：数据+流程（操作）；于是我们开发了一个支撑各种数据定义，以及各种循环，判断，分支等流程语法的软件。当我们把这款软件交给桃子老板时，老板就骂街了：因为我们给他的是一个JDK，产品文档是java开发手册，他要做的事情是配置一堆代码完成他想要的功能。

我们可以通过这个例子看出一些规律：
- 抽象过低的前期工作量最小，而且对于客户来说使用最方便，但一旦业务场景扩张或者需求开始膨胀，过低抽象的短板开始体现，最终可能需要给每个客户定制一个软件。
- 适当抽象的前期工作量略大，在客户界面需要进行一些个性化配置；但是由于抽象带来的可扩展性，在业务场景扩张和需求变更时，受冲击的影响较小，最终的总工作量会远小于不做抽象。
- 抽象太高的前期工作量极大，对于非专业人士来说使用起来极为困难；反之其带来的好处是极为灵活，如果业务场景和需求并没有按照预期进行扩张，会造成前期的工作量浪费；而且一旦抽象过头甚至可能会失去意义（过高的抽象虽然灵活，但由于抛弃了过多的个性，导致这些个性逻辑会下沉到业务模块中，毕竟我们不可能真的将JDK交给客户，有时候**什么都能做等于什么都不能做**）

总的来说：
- **抽象的层次越高 -> 相对趋向于灵活、稳定、易复用但难以应用**
- **抽象的层次越低 -> 相对趋向于僵硬、异变、难复用但容易应用**

抽象的高度不宜过高，也不宜过低；在高度相差较大的抽象层中间考虑适当增加中间抽象和模块，比如在生物和张三之间，保留动物，人这两层抽象；

软件设计总是会陷入这种两难的境地：向左是不抽象————设计薄弱，丢失扩展性；向右是抽象过高————过度设计，浪费人力；

所以又回到了耍赖的阶段：最好的抽象是“刚刚好”。下面这段话是我最喜欢的一段话，最能表达什么是“刚刚好”：


**根本不存在充分分析这种东西，无论花多少时间试图去找出完美的软件结构，客户总是会引入一个变化破坏这个结构。这种情况是无法避免的，不存在完美的结构，只存在试图去平衡当前的代价和收益的结构。随着时间的过去，这些结构肯定会随着需求的改变而改变，管理这种变化的诀窍是尽可能的保持系统的简单灵活。**
                                      ——摘自bob大叔《敏捷软件开发 原则、模式与实践》
									  
> 抽象的高度是一个相对概念，这里会存在一个误区，很多人认为只有接口和抽象来才是抽象，其实不然，连最基本的int类型相对于整数1,2,3来说也是抽象。

### 5. 总结

抽象是所有设计原则的基础，而设计原则又是所有设计模式的基础。

任何两个事务都可以抽象到同一个概念上来：java的Object类就是所有对象的顶级抽象，call、run、action等函数就是所有行为的顶级抽象；