我并认为这些剩下的原则算得上是原则，但是仍然有必要做出一些说明。

### 1. 接口隔离原则
**接口隔离原则(Interface Segregation Principle, ISP)：不应该强行要求客户端依赖于它们不用的接口；**
接口隔离原则，指的是接口太胖，导致子类在复用接口的api时，需要实现很多无关的方法。出现这种情况一般就两个原因：
- 接口做的事（定义的方法）太多；
- 越级把下级接口的事做了；
这本身就是违反单一原则的两个最基本体现。

### 2. 最少知道原则
**最少知道原则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用;**
违反最少知道原则本质就是越级。有时是自己关注了自己下级的太多细节，有时候是关注了别人下级的细节，同一个层次的人就应该与同一个层次的人对话；

### 3. 里氏替换原则
**里氏替换原则（Liskov Substitution Principle, LSP）：所有引用基类的地方必须能使用其子类的对象进行替换**

里氏替换原则和单一职责原则和依赖倒置原则还真没有什么关系，但我个人认为它并不能算作一个原则，更像一个指导性意见。

在讲里氏替换原则前，我们先看一个最基本的代码复用问题：
```
public static void methodA() {
    // code block 1 : do some special operation A
    // code block 2 : much code is same as code block 4
}

public static void methodB() {
    // code block 3 : do some special operation B
    // code block 4 : much code is same as code block 2
}
```
上面的methodA和methodB有很多代码是一样的，我想问下，当大家碰到这种情况，是否会抽一个公共方法复用代码？
```
public static void methodA() {
    // code block 1 : do some special operation A
    method();
}

public static void methodB() {
    // code block 3 : do some special operation B
    method();
}

private static void method() {
    // code block 2
}
```
如果不复用，以后code block 2的逻辑有修改，需要改多处，对吗？
但如果复用，可是有一天methodA的逻辑变了，需要修改method方法，但是methodB并不需要任何改动呢？
如果我们直接修改method方法，会导致methodB的原有业务出现错误；最终我们不得不将method还是分成了两份。

其实是否复用，是需要我们作出一些未来判断的。如果两段代码是一个变化因子控制的，则应该抽到一起复用的；但如果是两个不同变化因子控制的，即使代码相同，也应该分开（分开的粒度可以斟酌）。
> 如果看不清业务的变化，建议先复用。因为先复用，后面真的发生分歧，我们很容易找到方法的所有调用者，然后根据实际情况再分开即可；但如果不复用，则很难知道还有其他地方也有相同的逻辑，很可能出现漏改，比如只改了methodA，忘记修改了methodB。

从例子可以看出，复用有时候确实是可能带来一些“恶果”的：修改公共方法，会影响到所有人；而一旦其中部分使用者的行为出现不一致，而且刚好我们疏忽了这些不一致，便会产生错误。

但是，就因为这个可能存在而且可以避免的“恶果”，**我们就要抛弃复用吗**？

继承的本质是子类复用了父类的一些方法。但是可能有一天，某个子类的业务逻辑更改，导致它不得不重写一个父类的方法。这将会产生一些后果：
- 使用父类的地方并不知道子类的存在，可能因为它的特立独行产生一些错误的预期；
- 父类修改自己的方法时，期望所有子类都被更改，但是重写了方法的子类并不受改动影响；
即里氏替换所说的：引用基类的地方有可能出现无法使用其子类的对象进行替换的场景。

这是不是和复用公共方法非常相似：因为一旦这些共用者出现不一致，而我们又修改了这个公共方法时，就可能会出现问题。

里氏替换原则，正是在提醒我们，警惕这种重写了父类的方法可能导致的“恶果”。但是有些“大师”，会将里氏替换原则理解为：多用组合，少用继承。
而且还堂而皇之的举出一些例子，诸如正方形不是长方形:
```
public class Rectangular {
    protected int width, height;

    public void setHeight(int height) {
        this.height = height;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    public int getArea() {
        return this.width * this.height;
    }

}

public class Square extends Rectangular {

    @Override
    public int getArea() {
        return this.width * this.width;
    }
}
```
原因是，如下代码，当传入的是长方形和正方形得到的结果不一样，即子类不能代替父类。
```
public void test(Rectangular rectangular) {
    rectangular.setWidth(5);
    rectangular.setHeight(6);
    Assert.assertEquals(rectangular.getArea(), 30);
}
```


我在想，难道这些“大师”是建议我们正方形应该组合长方形吗？代码又该如何写呢？像下面这样？
```
public class Rectangular {
    protected int width, height;

    public void setHeight(int height) {
        this.height = height;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    public int getArea() {
        return this.width * this.height;
    }
}

public class Square {

    private Rectangular rectangular;

    public Square() {
        this.rectangular = new Rectangular();
    }

    public void setLength(int length) {
        this.rectangular.setHeight(length);
        this.rectangular.setWidth(length);
    }

    public int getArea() {
        return this.rectangular.getArea();
    }
}

```
如果有100个方法呢，然后正方形必须把所有长方形的方法转调一次？test方法又该如何兼容两者呢？是不是还得将长方形和正方形抽象出一个公共的接口？
```
public interface IRectangular {

    public void setHeight(int height);

    public void setWidth(int width);

    public int getArea();

    public void method1();
    public void method2();

    // ....

    public void method100();
}

public class Rectangular implements IRectangular {
    protected int width, height;

    @Override
    public void setHeight(int height) {
        this.height = height;
    }

    @Override
    public void setWidth(int width) {
        this.width = width;
    }

    @Override
    public int getArea() {
        return this.width * this.height;
    }

    @Override
    public void method1() {
    }

    @Override
    public void method2() {
    }

    // ....

    @Override
    public void method100() {
    }
}

public class Square implements IRectangular {

    private Rectangular rectangular;

    public Square() {
        this.rectangular = new Rectangular();
    }

    public void setLength(int length) {
        this.rectangular.setHeight(length);
        this.rectangular.setWidth(length);
    }

    @Override
    public void setHeight(int height) {
        this.setLength(height);
    }

    @Override
    public void setWidth(int width) {
        this.setLength(width);
    }

    @Override
    public int getArea() {
        return this.rectangular.getArea();
    }

    @Override
    public void method1() {
        this.rectangular.method1();
    }

    @Override
    public void method2() {
        this.rectangular.method1();
    }

    // ....
    @Override
    public void method100() {
        this.rectangular.method100();
    }

}
```
然后test方法这样写？
```
public void test(IRectangular rectangular) {
    rectangular.setWidth(5);
    rectangular.setHeight(6);
    Assert.assertEquals(rectangular.getArea(), 30);
}
```
可是test方法还是没法通过啊！难道要分成两个方法？
```
public void test1(Rectangular rectangular) {
    rectangular.setWidth(5);
    rectangular.setHeight(6);
    Assert.assertEquals(rectangular.getArea(), 30);
}

public void test2(Square square) {
    square.setWidth(5);
    square.setHeight(6);
    Assert.assertEquals(square.getArea(), 36);
}
```

那是不是原有的那些本来兼容长方形和正方形的函数，全部都要分成两个方法来区别对待这两个类型呢？

鄙人无能，实在是想不出该如何使用组合解决这种问题，我想也不可能解决这个问题，因为正方形和长方形的getArea逻辑本就不一样。

继承，很多时候是希望通过父类屏蔽子类的个性的；而组合，更多的是一个类充当另一个类的组成部分，比如一个属性，一个部件。
两者本身的应用场景就不相同，而且组合和继承均有优缺点，我们不应通过特定案例来放大其中一方的缺点并以此来否定它。

### 4. 合成复用原则
**合成复用原则(Composite Reuse Principle, CRP):尽量使用对象组合,而不是继承来达到复 用的目的。**

滚！


