之前讨论过，真正的设计原则只有两个：单一职责和依赖倒置。
单一职责原则关注的是分，即抽象的水平和垂直拆解。单一职责的理论其实很简单，但是做好极难，它需要架构师对业务有很深的理解，同时也需要架构师本身具备极强的抽象能力——这是一种能看穿事务本质的能力。
毫不避讳的说，单一职责原则所需要的这种抽象能力，是不可能教会的。不仅仅是我，所有讲单一职责原则或抽象的书，都只能举些例子告诉大家，什么是抽象，什么是变化因子，找到规律，然后拆开即可。但是我相信不会有人是通过看了某某的书，听了某某的教导，于是学会了抽象。最终一定是自己悟出来的！
这就好像我们中学上的几何数学，老师说，这道题需要作一条辅助线，然后举了个例子，什么是辅助线，怎么作辅助线，于是大家都懂了；但是只要遇到一个新的题目，尽管所有人都知道作辅助线是一种解题思路，但依然不会。首先，我们没法确定这道题是不是一定要作辅助线，其次，即使我们确定要作辅助线，但是这条辅助线是该从A点连到BC的中点，还是在哪里划一条垂直线，有没有可能要作三条？仍然不清楚！更可恶的是，我们会发现，即使你非常勤奋，你做了别人十倍的习题，但最终也不一定比得过一个有数学天赋的人。
这是一个悲伤的结论，但事实如此。

但依赖倒置原则不同，它是拆解过后的治理动作，我们根据各个模块或类的层级高低，稳定性等因素对这些模块或类进行一些隔离（BA模式转换或ACB模式转换），让这些组件的变化互不影响或影响很小即可。这些是可以依葫芦画瓢的。

23中设计模式几乎都是依赖倒置原则的实践者！
> 设计模式对单一职责原则几乎没有涉及，我们会看到一个设计模式的出场就已经定义好了场景和里面的一些概念，设计模式主要讨论的则是在这种概念划分下如果解决依赖导致的关联变化问题，至于如何划分，为什么划分是没有提及的。

接下来的整个章节，我将从每个模式的原始场景触发，剖析依赖导致原则的BA模式和ACB模式是如何应用并最终形成一个一个的模式的。

在开始讨论前，有几个点需要读者们注意：
#### 1. 聚焦设计本身，忽略那些与设计无关的纯技术或语法讨论；
设计更多的是一种思想，而不是代码。我听过很多人讲设计模式，总是会陷入到一些技术或语法的细节讨论之中，而忘记了设计本身，这种观点很容易将听众引入歧途，对设计的理解陷入迷糊。这里有两个很有代表性的例子：
1. 很多人说观察者模式使用了for循环，可能会因为一个观察者阻塞而产生性能问题。这明显是谬论，任何顺序执行的语句都有可能因为同步阻塞引入性能问题，观察者模式只是使用了一个for循环，就被扣了一顶帽子，属实冤枉。我想，在不使用并发编程的前提下，你不使用观察者模式也一样解决不了所谓的性能问题吧。这本质是一个性能需求，通过技术手段解决就好了，与观察者模式没有半毛钱关系。
2. 还有人不停的纠结单例模式哪种写法是最完美的，最终双层加锁，内部类等各种分析都出来了。这些难道不是java的一些语法或技术点吗？没有内部类的语言不配拥有单例模式吗？Spring框架所管理的对象基本都是单例，又哪里见过这些所谓单例代码的影子？深究一些技术点固然没错，但不要带偏，这些不是设计讨论的范畴。

#### 2. 每一个设计模式都会按照以下几个主题进行描述
- 原始需求和代码
每一个设计模式，我都会先给出一个极简的原始需求，和最简单的实现方法。
- 演变过程
我会在最原始的需求下，逐步添加一些上下文或需求，我们必须使用最有效的方式解决这种需求变动。并给出最终的类图。
- 思路扩展
我会以自问自答的方式，阐述该设计模式中需要注意的一些要点或比较常见的错误理解。
- 其他
如果有一些不包含在上面的内容需要补充，我会写在这里。

#### 3. 牢记下面这段逻辑，这是所有设计模式最基本的演变方式；
之前有总结过BA模式和ACB模式的使用场景：

满足以下所有情形，使用**BA模式**：
- 情形1： B是可控模块，即我们可以要求B按照我们定义的接口去实现。
- 情形2： B可能存在多种实现方式，即未来可能会有B1，B2出现；或者A→B违反了稳定依赖原则（A是更高层的模块，不应该依赖于B）
- 情形3： 不涉及对B对象的直接创建；

存在以下情形之一，使用**ACB模式**
- 情形4： 有很多A依赖同一个B，而且这些A的变化行为比较一致（会同时一起变化）；
- 情形5： B是不可控模块，而且A对稳定性的要求较高；

即
```
if (情形1 & 情形2 & 情形3) {
    BA模式;
} else if (情形4 || 情形5){
    ACB模式;
} else {
    // 这种情况属于A依赖于B天经地义。
    无需处理，A跟随B关联修改即可。
}
```
#### 4. 其他
每种设计模式都存在多种变换，在讨论的过程中，我可能只会挑选最基本的场景进行说明，有时甚至可能脱离原著中的场景设定，读者不必纠结本书和其他书孰对孰错；
另外，23种设计模式中的很多类图都很雷同或者部分雷同，这是必然的，因为他们绝大多数都是BA转换；
我们更应该关注的是在不同的应用场景下，这些类结构变换的驱动和思路，而不是最终结果。
> 如果我们把所有设计模式中最终类图中的类名和方法名保持一致，会发现，很多模式的类图简直一模一样。