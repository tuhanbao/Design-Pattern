### 1. 原始场景和代码
B模块是一个厨师专用的api库，里面有很多公共方法，比如放调料，放食材，调节火候。
```
/**
 * 放调料
 * 调料应该是一个对象，我们暂且以String来替代
 */
public static void putSpice(String spice) {
	// ...
}

/**
 * 放食材
 * 食材应该是一个对象，我们暂且以String来替代
 */
public static void putFood(String food) {
	// ...
}

/**
 * 调节火候
 */
public static void setHeat(int percent) {
	// ...
}

```

### 2. 演变过程
需求一：**我们需要增加一些后操作，诸如上色，图阴影或者加花边。**
我们发现，这个和桥接模式的需求一模一样，沿用桥接模式的代码就可以了。
而且我们知道，会有三种方式进行选择。

需求二：**我们希望可以共用shape实例**
这条需求是装饰模式最区别于其他参数化设计的地方，从装饰模式的名字看：他的两个变化因子，一个是主体抽象，而另外一个变化因子则隶属于主体抽象，譬如一些修饰属性或行为。
根据我们在桥接模式中的讨论，选择将抽象主体shape参数化是更好的选择（见桥接模式中一章）：
```
// 完全拷贝了桥接模式中思路扩展中的方式二
public interface Shape {
	void draw();
}

public interface Style {
	void drawShape();
}

public abstract class AbstractShape implements Shape {
	protected Style style;
	
	public AbstractShape(Style style) {
		this.style = style;
	}
	
	@Override
	public void drawShowy() {
		this.style.drawShape();
		postProcess();
	}
	
	public abstract void postProcess();
}

public class ColorPaintShape extends AbstractShape {
	private Color color;
	
	@Override
	public void postProcess() {
		// 上色
		drawColor(this.color);
	}
}

public class ShadowerShape extends AbstractShape {
	@Override
	public void postProcess() {
		// 图上阴影的具体操作
		// ...
	}
}

public class LacePaintShape extends AbstractShape {
	private Color color;
	
	@Override
	public void postProcess() {
		// 画上不同颜色花边的处理操作
		drawLace(this.color);
	}
}


public class Circle implements Style {
	@Override
	public void drawShape() {
		// 画一个环
		drawRing(...);
	}
}

public class Rectangle implements Style {
	@Override
	public void drawShape() {
		// 画四条线
		drawLine(...);
		drawLine(...);
		drawLine(...);
		drawLine(...);
	}
}

public class Triangle implements Style {
	@Override
	public void drawShape() {
		// 画三条线
		drawLine(...);
		drawLine(...);
		drawLine(...);
	}
}

```

需求三：**对旧代码尽量不要有影响**

上面的方式修改后对以前的Shape使用者很不友好，因为以前使用Circle、Rectangle和Triangle的地方，可能我不需要增强功能，也要修改代码
```
// 比如以前一个函数
public void test(Shape shape) {
	// ...
}

// 如果不使用增强功能，则需要改为：
public void test(Style style) {
	// ...
}
// 这样对很多代码都有影响
```

要解决这个问题也很简单，可以直接让Style继承Shape即可，当然，更简单的方式，就是直接复用Shape这个接口:
```
```
// 完全拷贝了桥接模式中思路扩展中的方式二，仅仅合并了两个接口而已
public interface Shape {
	void draw();
}

public abstract class AbstractShape implements Shape {
	protected Shape shape;
	
	public AbstractShape(Shape shape) {
		this.shape = shape;
	}
	
	@Override
	public void drawShowy() {
		this.shape.drawShape();
		postProcess();
	}
	
	public abstract void postProcess();
}

public class ColorPaintShape extends AbstractShape {
	private Color color;
	
	@Override
	public void postProcess() {
		// 上色
		drawColor(this.color);
	}
}

public class ShadowerShape extends AbstractShape {
	@Override
	public void postProcess() {
		// 图上阴影的具体操作
		// ...
	}
}

public class LacePaintShape extends AbstractShape {
	private Color color;
	
	@Override
	public void postProcess() {
		// 画上不同颜色花边的处理操作
		drawLace(this.color);
	}
}


public class Circle implements Shape {
	@Override
	public void draw() {
		// 画一个环
		drawRing(...);
	}
}

public class Rectangle implements Shape {
	@Override
	public void draw() {
		// 画四条线
		drawLine(...);
		drawLine(...);
		drawLine(...);
		drawLine(...);
	}
}

public class Triangle implements Shape {
	@Override
	public void draw() {
		// 画三条线
		drawLine(...);
		drawLine(...);
		drawLine(...);
	}
}

```

装饰者的代码模型便出来了。


### 3. 思路扩展
1. 外观模式本质是ACB转换
外观模式本质就是一种最基本的ACB转换，我们甚至不用刻意去记忆或学习，只要满足了特定场景，我们别无选择，即使一个从未学习过设计模式的新人，也会自然而然使用外观模式。
试想一下，B模块是一个给其他周边模块提供功能的基础模块，现在已经提供了许多原子接口api1, api2,...apiN;
此时周边某个网元又提出了一个新的要求，需要完成某某功能，但是这个功能需要组合api1,api3和api5才能完成，试想如果B模块是乙方的情况下，B模块的程序员会有选择吗？
他只能提供一个新的apiX:
```
public void apiX() {
	api1();
	api3();
	api5();
}

```

而这种通过包装一层原子接口对外提供高级接口的过程就是外观模式的核心。
即使这个程序员完全不知道复用，重新实现了一个apiX：
```
public void apiX() {
	// 平铺api1, api3和api5的逻辑
	// ...XXX行代码
}

```
这依然属于外观模式，它通过一个简单的api对外暴露了一个复杂的功能，让外部网元尽肯能少的感知本模块内的细节，只是这种实现没有复用已有的代码而已。

2. 外观模式不仅仅是方便外部调用者，有时是为了保护自己
ACB转换我们讨论过，当B是弱势方时，可以增加一个C保护自己。
当外部网元对本模块要求过多而且频繁变化时，我们可以增加一些facade，保护本模块内部的逻辑不变。
只是对外接口出现变动或新增需求时，我们可能需要修改某个facade或增加一个facade，但至少内部的原有逻辑不会受到影响。

2. 很多时候封装公共函数就是ACB转换。
这个概念在依赖倒置一章中有提过一次；在这里又强调一遍，是因为外观模式与我们平常封装的一些工具方法的思路实在是太像了：

我们知道，jdk提供的原始API是固定的，无法更改，但有时候我们希望有一些更高级的功能封装，此时就可以通过将底层jdk的api封装成一个新的接口提供给client使用。
当出现新的公共功能需求时，我们会封装更多的工具类方法，而这些工具类方法，就像是jdk底层api的一个个门面。
比如：

```
/**
 * 将一个int数组通过sep拼接成一个字符串
 */
public static String array2String(int[] array, String sep) {
    if (array == null || array.length == 0) {
        return Constants.EMPTY;
    }
    StringBuilder sb = new StringBuilder();
    int length = array.length;
    sb.append(array[0]);
    for (int i = 1; i < length; i++) {
        sb.append(sep).append(array[i]);
    }
    return sb.toString();
}

```

调用者只需要知道，他想将一个int数组拼成字符串调用这个方法就好了，至于如果实现，需要使用哪些底层api，它并不关心。