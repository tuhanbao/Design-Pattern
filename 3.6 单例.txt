### 1. 原始场景和代码
有一个java对象，我们永远只需要一个实例。

好像不需要啥特别注意的，我就只new一次就好了。为了方便别人使用，我将其声明为public static即可。
```
public static A a = new A();
```

### 2. 演变过程
好像并不需要演变，单例的需求就是如此，上面的代码也已经足够满足需求了。

### 3. 思路扩展
1. 单例模式并不是一种设计模式
单例模式应该是设计模式中很另类的模式之一。其他模式都会通过一些设计手段，诸如拆解，依赖转换，抽象等方式，以达到对某种变化进行隔离的效果。而单例没有！
整个单例模式中甚至没有第二者的存在，也就不会存在“依赖”的概念。

我想，能称得上“设计”的模式，至少要比普通方式带来一些更好的效果，比如扩展性，隔离，复用（这三个词很多时候是一个意思）。
但是单例模式的写法似乎并没有比最原始的代码在设计上优越多少，它只是在教我们如何从技术上保证一个类只可能生成一次而已，而且还保证不了。
比如：
```
public class A {
    private static final A INSTANCE = new A();

    private A() {

    }

    public static A getInstance() {
        return INSTANCE;
    }
}
```
我们通过简单的三行代码就可以轻易生成一个A的实例：
```
Constructor<?> constructor = A.class.getDeclaredConstructors()[0];
constructor.setAccessible(true);
A a = (A)constructor.newInstance();
```

在实际工作中，单例模式更多的是一种警示作用，就和我们加了一行醒目的注释一样。当我们看到单例类似的代码，我们就会立马明白：哦，这个类只需要实例化一次，我们可以通过getInstance()使用它。
试着思考下面两个问题，就会明白“单例模式”并不是我们实现单例需求的关键：
- spring使用大量的单例，但是你不会见到单例模式的任何代码。即使这样，也不会有人手动去new一个Service或者Controller类，那么spring用的到底算不算单例模式？
- 如果一门语言，没有private这种类似的关键字，是否就没有资格使用单例模式了，甚至没法实现一个单例需求？

我们完全可以使用一种约定俗成的非技术手段通知到其他程序员，这个类只需要实例化一次。

我想，单例最重要的点应该是教会我们警惕那些没有必要的浪费。不仅仅是类，包括任何占用资源的东西：一个属性，一个线程，一段代码，如果可以共用，那就没必要创建多份。

所以，单例模式，我更愿意称之为一种节约资源的思想，或者说是某种代码模式，但绝不是设计模式！

2. 关于单例的写法
但凡现在讲到单例，一定会讨论诸如懒汉式，饿汉式，线程安全，甚至会讨论双层加锁，内部类，编译器优化等。
我想可能是因为单例过于简单那，所以我们不得不讨论点别的来填充篇幅吧。
上面这些技术点明显不是单例的专属特点，但凡是涉及到性能，线程安全，都有可能使用到这些技术点。
我只能这么理解：这些人明显不是冲着学设计来的，他们可能更想搞懂jvm的底层机制，虽然单例本身也没有什么设计上的思想。

