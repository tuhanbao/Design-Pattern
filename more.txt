简单工厂：ACB
抽象工厂：ACB+BA
生成器：参数化
工厂方法：BA
原型：BA
单例：不是设计模式

适配器：ACB
桥接：参数化
组合：BA
装饰：参数化
外观：ACB，保护的是B
代理：参数化，1*1的参数化看起来像ACB，但实际不是。代理的变种和装饰很像
享元：不是设计模式

责任链：ABs的变种
命令：方法的顶级抽象
解释器：BA模式，对一种解释性算法的抽象
迭代器：BA转换，分开迭代器，只是为了隔离遍历，可以多个人同时遍历
中介者：ACB的混合，至于ABs只是常用的配合手段而已。
备忘录：不是设计模式
观察者：ABs，原著Subject也使用了BA，实际没啥必要，看情况而定
状态：反参数化（可能要再讲讲，反参数化，通常并不能去掉client的参数，参数化也是如此，client并不会增加参数。对于明确调用关系的client，会起到增减参数的作用，但是本身就是参数的client，参数依然在，但可能会改变形式）
策略者模式：同状态，反参数化。变种可能会更好用，不由client来选择
模板：反参数化+抽象
访问者：分支变方法。完全是基于变化的考虑



-- ACB；在孙子哪边
-- BA：在大爷那边，本质是一种抽象
参数化：拆解后复用，复用很多时候会依赖BA，本质也是一种抽象。
-- ABs：数据结构解耦
反参数化：ABs的一种形式
通过变化因子分解模块，然后隔离彼此之间的影响。

* 参数化反参数化：可能要重新理清楚，是不是删除反参数化。参数化本质就是拆

* ACB的特殊用法：通过继承
如何区别ACB和普通的拆解：前者为了隔离AB变化，后者？


* 拆解的目的只有复用：读复用和写复用